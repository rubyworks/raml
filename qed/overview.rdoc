= Ruby As Markup Language

Require the RAML library.

  require 'raml'

Given a RAML document:

  website "http://rubygems.org"

We can load the text via the #load method. (Note above document text has
been placed in the @text variable.)

  raml = RAML.load(@text)

The result is a RAML object, which can be converted to more usable form
via #to_h.

  data = raml.to_h

  data.assert == {:website=>"http://rubygems.org"}

One of the nicer features of RAML derives from Ruby's block notation, allowing
for nested entries.

Given a RAML document:

  resources do
    home ""
    docs ""
    wiki ""
  end

RAML is also considers the content of a block. If it is a scalar entry,
such as a String, then that will be assigned to the key.

Given a RAML document:

  description do
    "This is a description.\n"
    "It can have multiple lines.\n"
    "RAML handles this just fine,\n"
    "because Ruby would too."
  end

Loading this document,

  raml = RAML.load(@text)

The result is a RAML object, which can be converted to more usable form
via #to_h.

  data = raml.to_h

  data[:description].assert.start_with?("This is")
  data[:description].assert.end_with?("would too.")

RAML has some options that makes it more flexible than many other data
lanaguages. For instance, it can allow for multi-key entries.

Given a RAML document:

  source "http://rubygems.org"
  gem "facets", "~> 2.8"
  gem "ansi", "~> 1.1"

We simply need to inform the loader to allow identical keys.

  raml = RAML.load(@text, :multikey=>true)

  data = raml.to_h

  data.assert == {
    :source=>"http://rubygems.org",
    :gem=>[["facets", "~> 2.8"],["ansi", "~> 1.1"]]
  }

If we did not turn on the multi-key option, then the last `gem` entry
would have simply overwritten the former.

  raml = RAML.load(@text)

  data = raml.to_h

  data.assert == {
    :source=>"http://rubygems.org",
    :gem=>["ansi", "~> 1.1"]
  }


